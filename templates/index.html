<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Microscope Control</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f4f4f4; color: #333; }
        .container { display: flex; flex-wrap: wrap; gap: 20px; }
        .column { flex: 1; min-width: 300px; background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        .column h2 { color: #5a5a5a; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        .column h3 { color: #666; margin-top: 20px; }
        label { display: block; margin-top: 10px; font-weight: bold; }
        select, input[type="number"], input[type="text"] { width: calc(100% - 22px); padding: 10px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; }
        button { background-color: #007bff; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; margin-right: 5px; }
        button:hover { background-color: #0056b3; }
        button.stop { background-color: #dc3545; }
        button.stop:hover { background-color: #c82333; }
        .status-light { height: 10px; width: 10px; background-color: #bbb; border-radius: 50%; display: inline-block; margin-left: 10px; }
        .status-light.active { background-color: #28a745; }
        #videoFeed { max-width: 100%; height: auto; border: 1px solid #ddd; margin-top: 10px; }
        ul { list-style-type: none; padding: 0; }
        ul li { background-color: #e9ecef; margin-bottom: 5px; padding: 8px; border-radius: 4px; }
    </style>
</head>
<body>
    <h1>Microscope Control</h1>
    <div class="container">
        <div class="column" id="main-controls">
            <h2>Live Feed</h2>
            <img id="videoFeed" src="{{ url_for('video_feed') }}" alt="Video Feed">
            
            <h3>Master Controls</h3>
            <button id="startCamera">Start Camera</button>
            <button id="stopCamera" class="stop">Stop Camera</button>
            <span id="cameraStatus" class="status-light"></span> Camera
            <hr>
            <button id="startStream">Start Stream</button>
            <button id="stopStream" class="stop">Stop Stream</button>
            <span id="streamStatus" class="status-light"></span> Stream
            <hr>
            <button id="startStorage">Start Recording</button>
            <button id="stopStorage" class="stop">Stop Recording</button>
            <span id="storageStatus" class="status-light"></span> Recording (<span id="storageFileStatus">Idle</span>)
            <hr>
            <button id="startTimelapse">Start Timelapse</button>
            <button id="stopTimelapse" class="stop">Stop Timelapse</button>
            <span id="timelapseStatus" class="status-light"></span> Timelapse (<span id="timelapseFramesStatus">0 frames</span>)
        </div>

        <div class="column" id="settings-column">
            <h2>Settings</h2>
            <div id="settingsContainer">
                <!-- Camera Settings -->
                <h3>Camera</h3>
                <label for="camResolution">Resolution:</label>
                <select id="camResolution" data-setting-path="camera.resolution"></select>
                <label for="camFps">FPS:</label>
                <input type="number" id="camFps" data-setting-path="camera.fps" min="1" max="60">
                <label for="camBrightness">Brightness (0-100):</label>
                <input type="number" id="camBrightness" data-setting-path="camera.brightness_ui" min="0" max="100">
                <label for="camContrast">Contrast (0-100):</label>
                <input type="number" id="camContrast" data-setting-path="camera.contrast_ui" min="0" max="100">
                <label for="camSaturation">Saturation (0-100):</label>
                <input type="number" id="camSaturation" data-setting-path="camera.saturation_ui" min="0" max="100">

                <!-- Stream Settings -->
                <h3>Stream</h3>
                <label for="streamFps">FPS:</label>
                <input type="number" id="streamFps" data-setting-path="stream.fps" min="1" max="60">
                <label for="streamJpegQuality">JPEG Quality (1-100):</label>
                <input type="number" id="streamJpegQuality" data-setting-path="stream.jpeg_quality" min="1" max="100">
                <label for="streamProcessingMode">Processing Mode:</label>
                <select id="streamProcessingMode" data-setting-path="stream.processing_strategy_name"></select>

                <!-- Storage Settings -->
                <h3>Storage (Recording)</h3>
                <label for="storageFps">FPS (for recording):</label>
                <input type="number" id="storageFps" data-setting-path="storage.fps" min="1" max="60">
                <label for="storageProcessingMode">Processing Mode:</label>
                <select id="storageProcessingMode" data-setting-path="storage.processing_strategy_name"></select>
                <div>Output Directory: <span id="storageOutputDir"></span></div>


                <!-- Timelapse Settings -->
                <h3>Timelapse</h3>
                <label for="timelapseInterval">Interval (seconds):</label>
                <input type="number" id="timelapseInterval" data-setting-path="timelapse.interval" min="0.1" step="0.1">
                <label for="timelapseDuration">Duration (seconds, 0 for indefinite):</label>
                <input type="number" id="timelapseDuration" data-setting-path="timelapse.duration" min="0">
                <label for="timelapseMinFrames">Min Frames for Video:</label>
                <input type="number" id="timelapseMinFrames" data-setting-path="timelapse.min_frames" min="1">
                <label for="timelapseProcessingMode">Processing Mode:</label>
                <select id="timelapseProcessingMode" data-setting-path="timelapse.processing_strategy_name"></select>
                <div>Output Directory: <span id="timelapseOutputDir"></span></div>
                <div id="timelapseProgress"></div>
            </div>
            <button id="applyAllSettings">Apply Changed Settings</button>
        </div>

        <div class="column" id="files-column">
            <h2>Recordings</h2>
            <ul id="recordingsList"></ul>
            <button id="refreshRecordings">Refresh Recordings</button>

            <h2>Timelapses</h2>
            <ul id="timelapsesList"></ul>
            <button id="refreshTimelapses">Refresh Timelapses</button>
        </div>
    </div>

    <script>
        // Initial data from Flask/Jinja2
        let AppData = {{ page_data | tojson | safe }};
        let currentSettings = AppData.settings;
        let currentStatus = AppData.status;
        let changedSettings = {}; // To collect pending changes

        // --- UTILITY FUNCTIONS ---
        function getNestedValue(obj, path) {
            return path.split('.').reduce((acc, part) => acc && acc[part], obj);
        }

        function setNestedValue(obj, path, value) {
            const keys = path.split('.');
            const lastKey = keys.pop();
            const target = keys.reduce((acc, part) => acc[part] = acc[part] || {}, obj);
            target[lastKey] = value;
        }
        
        // --- API INTERACTION ---
        async function fetchAPI(url, options = {}) {
            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ message: response.statusText }));
                    throw new Error(`API Error (${response.status}): ${errorData.message || 'Unknown error'}`);
                }
                return await response.json();
            } catch (error) {
                console.error(error.message);
                alert(error.message); // Simple user feedback
                throw error; // Re-throw for further handling if needed
            }
        }

        async function updateSettingsAPI() {
            if (Object.keys(changedSettings).length === 0) {
                console.log("No settings changed.");
                return;
            }
            try {
                const data = await fetchAPI('/api/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(changedSettings)
                });
                if (data.success) {
                    console.log("Settings updated successfully:", data.settings);
                    currentSettings = data.settings; // Update local cache
                    populateUISettings(currentSettings); // Re-populate with confirmed settings
                    changedSettings = {}; // Clear pending changes
                    await fetchStatusAPI(); // Refresh status after settings change
                    alert("Settings applied!");
                }
            } catch (error) {
                // Error already logged by fetchAPI
            }
        }

        async function controlModuleAPI(component, action) {
            try {
                const data = await fetchAPI(`/api/control/${component}/${action}`, { method: 'POST' });
                if (data.success) {
                    console.log(data.message);
                    alert(data.message);
                    await fetchStatusAPI(); // Refresh status after control action
                }
            } catch (error) {
                // Error already logged by fetchAPI
            }
        }
        
        async function fetchStatusAPI() {
            try {
                const statusData = await fetchAPI('/api/status');
                currentStatus = statusData;
                populateUIStatus(currentStatus);
            } catch (error) {
                // Error already logged by fetchAPI
            }
        }

        async function fetchRecordings() {
            try {
                const data = await fetchAPI('/recordings');
                const recordingsList = document.getElementById('recordingsList');
                recordingsList.innerHTML = ''; // Clear existing
                if (data.recordings && data.recordings.length > 0) {
                    data.recordings.forEach(rec => {
                        const li = document.createElement('li');
                        li.textContent = rec;
                        recordingsList.appendChild(li);
                    });
                } else {
                    recordingsList.innerHTML = '<li>No recordings found.</li>';
                }
            } catch (error) {
                // Error already logged by fetchAPI
            }
        }

        async function fetchTimelapses() {
            try {
                const data = await fetchAPI('/timelapses');
                const timelapsesList = document.getElementById('timelapsesList');
                timelapsesList.innerHTML = ''; // Clear existing
                if (data.timelapses && data.timelapses.length > 0) {
                    data.timelapses.forEach(lapse => {
                        const li = document.createElement('li');
                        li.textContent = lapse;
                        timelapsesList.appendChild(li);
                    });
                } else {
                    timelapsesList.innerHTML = '<li>No timelapses found.</li>';
                }
            } catch (error) {
                 // Error already logged by fetchAPI
            }
        }

        // --- UI POPULATION ---
        function populateProcessingModes(selectElement, availableModes, currentMode) {
            selectElement.innerHTML = '';
            availableModes.forEach(mode => {
                const option = document.createElement('option');
                option.value = mode;
                option.textContent = mode.charAt(0).toUpperCase() + mode.slice(1);
                if (mode === currentMode) {
                    option.selected = true;
                }
                selectElement.appendChild(option);
            });
        }
        
        function populateCameraResolutions(selectElement, supportedResolutions, currentResolution) {
            selectElement.innerHTML = '';
            if (!supportedResolutions) supportedResolutions = []; // Ensure it's an array
            if (!currentResolution) currentResolution = [0,0]; // Default if undefined

            supportedResolutions.forEach(res => {
                const option = document.createElement('option');
                const resString = `${res[0]}x${res[1]}`;
                option.value = JSON.stringify(res); // Store as JSON string "[w,h]"
                option.textContent = resString;
                if (res[0] === currentResolution[0] && res[1] === currentResolution[1]) {
                    option.selected = true;
                }
                selectElement.appendChild(option);
            });
        }

        function populateUISettings(settings) {
            if (!settings) return;

            // Camera
            if (settings.camera) {
                document.getElementById('camFps').value = settings.camera.fps;
                populateCameraResolutions(document.getElementById('camResolution'), settings.camera.supported_resolutions, settings.camera.resolution);
                document.getElementById('camBrightness').value = settings.camera.brightness_ui;
                document.getElementById('camContrast').value = settings.camera.contrast_ui;
                document.getElementById('camSaturation').value = settings.camera.saturation_ui;
            }
            
            const availableModes = settings.available_processing_modes || [];

            // Stream
            if (settings.stream) {
                document.getElementById('streamFps').value = settings.stream.fps;
                document.getElementById('streamJpegQuality').value = settings.stream.jpeg_quality;
                populateProcessingModes(document.getElementById('streamProcessingMode'), availableModes, settings.stream.processing_strategy_name);
            }

            // Storage
            if (settings.storage) {
                document.getElementById('storageFps').value = settings.storage.fps;
                populateProcessingModes(document.getElementById('storageProcessingMode'), availableModes, settings.storage.processing_strategy_name);
                document.getElementById('storageOutputDir').textContent = settings.storage.output_dir;
            }
            
            // Timelapse
            if (settings.timelapse) {
                document.getElementById('timelapseInterval').value = settings.timelapse.interval;
                document.getElementById('timelapseDuration').value = settings.timelapse.duration;
                document.getElementById('timelapseMinFrames').value = settings.timelapse.min_frames;
                populateProcessingModes(document.getElementById('timelapseProcessingMode'), availableModes, settings.timelapse.processing_strategy_name);
                document.getElementById('timelapseOutputDir').textContent = settings.timelapse.output_dir;
            }
        }

        function populateUIStatus(status) {
            if (!status) return;

            document.getElementById('cameraStatus').classList.toggle('active', status.camera_running);
            document.getElementById('streamStatus').classList.toggle('active', status.stream_active);
            document.getElementById('storageStatus').classList.toggle('active', status.storage_active);
            document.getElementById('storageFileStatus').textContent = status.storage_active ? (status.storage_current_file || 'Recording...') : 'Idle';
            
            document.getElementById('timelapseStatus').classList.toggle('active', status.timelapse_active);
            if (status.timelapse_info) {
                let timelapseProg = '';
                if (status.timelapse_active) {
                    timelapseProg = `Frames: ${status.timelapse_info.current_frames || 0}. Next cap: ${status.timelapse_info.next_capture_in}s. Next vid: ${status.timelapse_info.next_video_in}s.`;
                } else if (status.timelapse_info.current_frames > 0) {
                     timelapseProg = `Paused. Frames: ${status.timelapse_info.current_frames || 0}.`;
                } else {
                    timelapseProg = 'Idle.';
                }
                document.getElementById('timelapseFramesStatus').textContent = `${status.timelapse_info.current_frames || 0} frames`;
                document.getElementById('timelapseProgress').textContent = timelapseProg;

            } else {
                 document.getElementById('timelapseFramesStatus').textContent = `0 frames`;
                 document.getElementById('timelapseProgress').textContent = 'Idle.';
            }
        }

        // --- EVENT LISTENERS ---
        function setupEventListeners() {
            // Control Buttons
            document.getElementById('startCamera').addEventListener('click', () => controlModuleAPI('camera', 'start'));
            document.getElementById('stopCamera').addEventListener('click', () => controlModuleAPI('camera', 'stop'));
            document.getElementById('startStream').addEventListener('click', () => controlModuleAPI('stream', 'start'));
            document.getElementById('stopStream').addEventListener('click', () => controlModuleAPI('stream', 'stop'));
            document.getElementById('startStorage').addEventListener('click', () => controlModuleAPI('storage', 'start'));
            document.getElementById('stopStorage').addEventListener('click', () => controlModuleAPI('storage', 'stop'));
            document.getElementById('startTimelapse').addEventListener('click', () => controlModuleAPI('timelapse', 'start'));
            document.getElementById('stopTimelapse').addEventListener('click', () => controlModuleAPI('timelapse', 'stop'));

            // Settings Inputs - accumulate changes
            const settingsInputs = document.querySelectorAll('#settingsContainer [data-setting-path]');
            settingsInputs.forEach(input => {
                input.addEventListener('change', (event) => {
                    const path = event.target.dataset.settingPath;
                    let value = event.target.value;
                    // Type conversion based on input type or specific ID
                    if (event.target.type === 'number') {
                        value = parseFloat(value);
                        if (isNaN(value)) {
                            console.warn(`Invalid number for ${path}: ${event.target.value}`);
                            // Optionally revert or show error
                            return; 
                        }
                    } else if (event.target.id === 'camResolution') {
                         try { value = JSON.parse(value); } catch (e) { console.error("Invalid resolution value", value); return; }
                    }
                    setNestedValue(changedSettings, path, value);
                    console.log("Staged settings changes:", changedSettings);
                });
            });
            
            document.getElementById('applyAllSettings').addEventListener('click', updateSettingsAPI);

            // File List Refresh Buttons
            document.getElementById('refreshRecordings').addEventListener('click', fetchRecordings);
            document.getElementById('refreshTimelapses').addEventListener('click', fetchTimelapses);
        }

        // --- INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', () => {
            if (!currentSettings || !currentStatus) {
                console.error("Initial page_data not loaded correctly. Check Flask template.");
                alert("Error loading initial page data. Please refresh.");
                // Attempt to fetch if initial data is missing (fallback)
                // fetchStatusAPI(); 
                // fetch('/api/settings').then(r=>r.json()).then(s => { currentSettings = s; populateUISettings(s); });
                return;
            }
            populateUISettings(currentSettings);
            populateUIStatus(currentStatus);
            setupEventListeners();
            fetchRecordings();
            fetchTimelapses();

            // Periodically refresh status
            setInterval(fetchStatusAPI, 5000); // Refresh status every 5 seconds

            // Reload video feed if it breaks (simple approach)
            const videoElement = document.getElementById('videoFeed');
            videoElement.onerror = function() {
                console.log("Video feed error. Attempting to reload...");
                setTimeout(() => {
                    // Add cache buster to src to force reload
                    videoElement.src = "{{ url_for('video_feed') }}?timestamp=" + new Date().getTime();
                }, 1000);
            };
        });
    </script>
</body>
</html> 